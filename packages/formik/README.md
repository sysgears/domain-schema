# Domain Schema React Forms with Formik

[![npm version](https://badge.fury.io/js/domain-react-forms.svg)](https://badge.fury.io/js/domain-react-forms) [![Twitter Follow](https://img.shields.io/twitter/follow/sysgears.svg?style=social)](https://twitter.com/sysgears)

## Installation

```bash
yarn add @domain-schema/formik @domain-schema/core @domain-schema/validation
```

or

```bash
npm install @domain-schema/formik @domain-schema/core @domain-schema/validation
```

## Usage

##### NOTE:  The current version properly works only for the web platform. Support for React Native forms will be added soon.

### Example

#### Simple form
The simple form - is a form generated by this package and based on domain-schema without
 fields with nested schema. 
This is how domain-schema without complex fields looks:
```js
  class User extends Schema {
    __ = { name: 'User' };
    id = DomainSchema.Int;
    name = {
      type: String,
      input: {
        label: 'Username'
      }
    };
    email = {
      type: String,
      input: {
        type: 'email',
        label: 'Email'
      },
      email: true
    };
    password = {
      type: String,
      input: {
        type: 'password',
        label: 'Password',
      },
      min: 5
    };
  }
```
This is how you can generate a basic form according to schema:
```js
// set components globally for all forms
DomainSchemaFormik.setFormComponents({
  input: RenderField,
  form: Form,
  button: Button
});

const userForm =  new DomainSchemaFormik(User);

const UserForm = userForm.generateForm({
  label: 'Save'
});

<UserForm onSubmit={values => {
    // handle submit
  }}>
```

#### Complex form
A complex form meaning the form that has a nested schema field that represents 
relations with the other schema. 

##### Advanced schema with One-To-One relationships
One-To-One is the relationship between two entities. A and B in which one element of A may only be linked 
to one element of B, and vice versa.
The One-To-One relation between schemas is shown in the code sample below.

 ```js
  class User extends Schema {
    __ = { name: 'User' };
    profile = {
      type: Profile
    };
   }
 
 class Profile extends Schema {
   __ = { name: 'Profile' };
   user = {
     type: User
   };
 }
 ````
 So, when One-To-One relation established - form with flat structure will be generated by default. Meaning
 nested schema fields will be inserted into the form.
Also, you could use ```fieldType``` property
with the value ```form``` to explicitly set up such behaviour.
```js
class Profile extends Schema {
  __ = { name: 'Profile' };
  user = {
    type: User,
    fieldType: 'form'
  }
}
```
This is how you can generate a complex form according to schema:
```js
const userForm = new DomainSchemaFormik(User);

// set components for particular DomainSchemaFormik instance
userForm.setFormComponents({
  input: RenderField,
  form: Form,
  button: Button
});

const UserForm = userForm.generateForm();

// Defining onSubmit prop is required
<UserForm onSubmit={(values, formikBag) => {
    // handle submit
  }}>
```
##### Advanced schema with One-To-Many relationships

One-To-Many is relationship between two entities. A and B in which an element of A may be linked to many elements of B,
but a member of B is linked to only one element of A. The one-to-many relation between schemas is shown in the code sample below.


```js
class Group extends Schema {
  __ = { name: 'Group' };
  // this field will be skipped by default
  users = {
    type: [User]
  };
}
class User extends Schema {
  __ = { name: 'User' };
  // for this field fieldType select will be defined by default
  group = {
    type: Group
  };
}
```
The field, with the nested schema, which implements has many relationship, will be not included in the form
 by default.
 But for the nested schema with belonging relation field type ```select``` will be defined by default. 
This is how you can generate a complex form according to schema:
```js
const groupForm =  new DomainSchemaFormik(Group);

// set components for particular DomainSchemaFormik instance
groupForm.setFormComponents({
  input: RenderField,
  select: RenderSelectQuery,
  form: Form,
  button: Button
});

const GroupForm = groupForm.generateForm();

// Defining onSubmit prop is required
<GroupForm onSubmit={(values, formikBag) => {
    // handle submit
  }}>
```
##### Advanced schema with Many-To-Many relationships
Current functionality in development


### Using different field types

When creating your schemas, you can pass various attributes to the fields. 
To pass attributes or properties to the field component, you can use ```input``` property in a schema. All fields can 
take three special attributes: ```onChange```, ```onBlur``` and ```type```. All other defined attributes will be passed
 to the field component. The attribute ```name``` is define automatically and set to the field name of the field that you 
 taken from the schema.

* ```input``` - is default ```fieldType``` and it can be omitted

  ```js
    email = {
      fieldType: 'input',
      input: {
        type: 'email',
        placeholder: 'User Email'
      }
    }
    post = {
      // fieldType: 'input'
      input: {
        placeholder: 'Your post',
        type: 'textarea',
        label: 'Post'
      }
    }
  ```

* ```checkbox```

  ```js
    active = {
      fieldType: 'checkbox',
      input: {
        label: 'Active'
      },
      defaultValue: true
    }
  ```

* ```select```

  ```js
    role = {
      fieldType: 'select',
      input: {
        label: 'User role',
        values: ['user', 'admin']
      }
    }
  ```

* ```radio```

  ```js
    friend = {
      fieldType: 'radio',
      input: {
        label: 'Very best friend',
        values: ['Gerald', 'Ashley']
      },
    }
  ```

To prevent generation of a specific field we can use ```ignore``` property

```js
  password = {
      type: String,
      input: {
        type: 'password',
        label: 'Password',
      },
      ignore: true
    };
```

Field components will get next props:

```js
{
      // all props which were specified in the input property in the schema
      ...,
      onChange, // if the callback was not specified in the input property, the Formik's handleChange will be used
      onBlur, // the same as OnChange
      type, // if the type was not specified in the input property, the fieldType will be used, if the fieldType is missing too, 'text' will be used
      name, //  will be define automatically and equals field name from the schema
      value, // if the defaultValue was not specified, the empty will be used as value
      meta // object with touched and error properties from Formik
}
```

### Buttons

To create a ```submit``` button in the form we need to pass object with attributes to the  ```generateForm``` method.
All attributes, that we define in the object will be passed to the button:

```js
  userForm.generateForm({
    label: 'Submit',
    className: 'submit-btn',
    color: 'primary'
  })
```

By default, ```submit``` button is disabled when form is invalid. To deactivate that behaviour we can define ```disableOnInvalid``` as ```false```

```js
  userForm.generateForm({
    label: 'Save',
    disableOnInvalid: false
  })
```

In some cases, providing a reset button for the user can be convenient. To create a reset button, we need
to pass an object to ```generateForm``` method with ```submit``` and ```reset``` properties. A ```Reset``` button,
as its name implies will reset form data to the initial (default) values.

```js
  userForm.generateForm({
    submit: {
      label: 'Submit',
      className: 'submit-btn'
    },
    reset: {
      label: 'Reset',
      className: 'reset-btn'
    }
  })
```

For positioning buttons, you can use the `align` property on a form, ```align```
 can take values ```left``` or ```right```. By default, its value is ```center```.

```js
  userForm.generateForm({
    label: 'Submit',
    align: 'left'
  })
```

Buttons are automatically wrapped in a DIV element with style ```display: flex```, so that any 
properties for flex items can be applied to them. For example, the order of buttons can be 
changed by setting css property order for the element's class.

### Set default field types

Default fields types can be set globally. For the common field you can define default ```fieldType``` by 
specifying ```plainFieldType``` property. Also you can define the default ```fieldType```  for the field with nested schema 
which has One-To-One relationship by specifying  ```oneToOneFieldType```. Likewise, you can define the default 
```fieldType```  for the field which has One-To-Many relationship by specifying ```oneToManyFieldType```.
```js
DomainSchemaFormik.setDefaultFormFieldTypes({
    oneToOneFieldType: 'form',
    plainFieldType: 'input',
    oneToManyFieldType: 'select'
});
```



### Set form components

In order to set which component to render for specific ```fieldType``` you can use ``setFormComponents`` method. Form field - component mapping can be set in two ways. Globally, for all forms:

```js
DomainSchemaFormik.setFormComponents({
  input: RenderField,
  select: RenderSelect,
  checkbox: RenderCheckBox,
  form: Form,
  button: Button
});
```

And locally, for particular DomainSchemaFormik instance:

```js
const userForm =  new DomainSchemaFormik(userFormSchema);

userForm.setFormComponents({
  input: RenderField,
  select: RenderSelect,
  checkbox: RenderCheckBox,
  form: Form,
  button: Button
});
```

### Submitting a Form

We should define ```onSubmit``` callback which will receive values from form fields as ```values``` and helper methods as ```formikBag```. More about these methods in official docs [FormikBag].

```js
<UserForm onSubmit={(values, formikBag) => {
    // handle submit
  }}>
```

### Generate form fields without form

If we need maximum flexibility, we can generate only fields without the form itself. For that we should use ```generateFields``` method instead of ```generateForm```. But note, that you should use Formik manually when you generating fields without form.

```js
const fieldSet = userForm.generateFields();
...
return <form>{fieldSet}</form>;
```

### Custom field generation

We can use custom field, defining ```fieldType``` as ```custom```
and specified field component in ```component``` prop. All necessary props can be provided via ```input```.

```js
  myField = {
    fieldType: 'custom',
    component: MyFieldComponent,
    input: {
      // all props that our component may need
    }
  }
```

## Validation

Please check [`@domain-scheam/validation` documentation](https://github.com/sysgears/domain-schema/tree/master/packages/validation).

## License

Copyright © 2017-2018 [SysGears INC]. This source code is licensed under the [MIT] license.

[MIT]: LICENSE
[SysGears INC]: http://sysgears.com
[FormikBag]: https://github.com/jaredpalmer/formik#the-formikbag
